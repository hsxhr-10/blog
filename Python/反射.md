#  反射

反射，或者叫自省，是指在运行时来获取一个对象相关信息的功能。Python 是动态的、解析型语言，有反射是很自然合理的。

## dir

内置函数 `dir()` 会返回一个列表，里面存放的是对象的所有成员变量和成员函数。

## type 和 id

内置函数 `type()` 返回对象的类型。内置函数 `id()` 返回对象的唯一 ID。

## inspect

标准库 `inspect` 能精准反射出对象的相关信息：module、class、method、function、code、generator、coroutine、builtin。

例如获取某个模块的所有函数：

```python
import inspect

functions = inspect.getmembers(module, predicate=inspect.isfunction)

for func_name, func in functions:
    pass
```

`predicate` 参数的取值还有很多，除了获取函数，还能获取类、类的方法等，就不一一列举了，具体[在这](https://docs.python.org/3/library/inspect.html#types-and-members)。

## `__xxxattr__()`

### `__getattr__()`

调用内置函数 `getattr()` 如果找不到对应属性时，默认抛出异常，如果定义了 `__getattr__()`，则走该方法：

```python
In [33]: class O:
    ...:     def __init__(self, name):
    ...:         self.name = name
    ...:
    ...:     def __getattr__(self, name):
    ...:         return "找不到属性，调用 __getattr__()"
    ...:
    ...:
    ...: o = O("tiger")
    ...: print(getattr(o, "name"))
    ...: print(getattr(o, "age"))
tiger
找不到属性，调用 __getattr__()
```

### `__setattr__()`

小心无限递归的陷阱：`obj.name = value` 和 `setattr()` 语句内部调用的都是 `__setattr__()`，所以，如果重写 `__setattr__()` 方法，在函数体里面不能出现 `obj.name = value`、`setattr()` 语句，否则会出现无限递归，直到爆栈。

爆栈例子：

```python
class O:
    def __init__(self, name):
        self.name = name

    def __getattr__(self, name):
        return "找不到属性，调用 __getattr__()"

    def __setattr__(self, name, value):
        print("调用 __setattr__()")
        self.name = value


o = O("tiger")

... ...
调用 __setattr__()
调用 __setattr__()
调用 __setattr__()
---------------------------------------------------------------------------
RecursionError                            Traceback (most recent call last)
<ipython-input-44-5e2d24e97a8b> in <module>
     10         self.name = value
     11
---> 12 o = O("tiger")

<ipython-input-44-5e2d24e97a8b> in __init__(self, name)
      1 class O:
      2     def __init__(self, name):
----> 3         self.name = name
      4
      5     def __getattr__(self, name):

<ipython-input-44-5e2d24e97a8b> in __setattr__(self, name, value)
      8     def __setattr__(self, name, value):
      9         print("调用 __setattr__()")
---> 10         self.name = value
     11
     12 o = O("tiger")

... last 1 frames repeated, from the frame below ...

<ipython-input-44-5e2d24e97a8b> in __setattr__(self, name, value)
      8     def __setattr__(self, name, value):
      9         print("调用 __setattr__()")
---> 10         self.name = value
     11
     12 o = O("tiger")

RecursionError: maximum recursion depth exceeded while calling a Python object
```

修复方法是使用 `self.__dict__[name] = value` 语句来赋值：

```python
In [45]: class O:
    ...:     def __init__(self, name):
    ...:         self.name = name
    ...:
    ...:     def __getattr__(self, name):
    ...:         return "找不到属性，调用 __getattr__()"
    ...:
    ...:     def __setattr__(self, name, value):
    ...:         print("调用 __setattr__()")
    ...:         self.__dict__[name] = value
    ...:

In [46]: o = O("tiger")
调用 __setattr__()

In [47]: setattr(o, "age", 23)
    ...: print(getattr(o, "age"))
调用 __setattr__()
23
```

### `__delattr__()`

也会存在无限递归的陷阱：`del obj.attr` 和 `delattr()` 内部调用的都是 `__delattr__()`，所以，当重写 `__delattr__()` 时，不能在函数体内出现 `del obj.attr`、`delattr()` 语句，否则会出现无限递归，直到爆栈。

爆栈例子：

```python
In [73]: class O:
    ...:     def __init__(self, name):
    ...:         self.name = name
    ...:
    ...:     def __getattr__(self, name):
    ...:         return "找不到属性，调用 __getattr__()"
    ...:
    ...:     def __setattr__(self, name, value):
    ...:         print("调用 __setattr__()")
    ...:         self.__dict__[name] = value
    ...:
    ...:     def __delattr__(self, name):
    ...:         del self.name
    ...:
    ...:
    ...: o = O("tiger")
    ...: del o.name
调用 __setattr__()

---------------------------------------------------------------------------
RecursionError                            Traceback (most recent call last)
<ipython-input-73-6b7a78ac553b> in <module>
     15
     16 o = O("tiger")
---> 17 del o.name

<ipython-input-73-6b7a78ac553b> in __delattr__(self, name)
     11
     12     def __delattr__(self, name):
---> 13         del self.name
     14
     15

... last 1 frames repeated, from the frame below ...

<ipython-input-73-6b7a78ac553b> in __delattr__(self, name)
     11
     12     def __delattr__(self, name):
---> 13         del self.name
     14
     15

RecursionError: maximum recursion depth exceeded
```

修复方法是使用 `del self.__dict__[name]` 语句来删除：

```python
In [74]: class O:
    ...:     def __init__(self, name):
    ...:         self.name = name
    ...:
    ...:     def __getattr__(self, name):
    ...:         return "找不到属性，调用 __getattr__()"
    ...:
    ...:     def __setattr__(self, name, value):
    ...:         print("调用 __setattr__()")
    ...:         self.__dict__[name] = value
    ...:
    ...:     def __delattr__(self, name):
    ...:         del self.__dict__[name]
    ...:
    ...:
    ...: o = O("tiger")
    ...: del o.name
调用 __setattr__()

In [75]: o.name
Out[75]: '找不到属性，调用 __getattr__()'
```

### `__hasattr__()`

也会有无限递归的陷阱：`hasattr()` 内部调用的是 `getattr()`/`__getattr__()`，所以，在重写 `__getattr__()` 时，不能出现 `hasattr()`、`__hasattr__()` 语句，否则会出现无限递归，直到爆栈。

爆栈例子：

```python
In [86]: class O:
    ...:     def __init__(self, name):
    ...:         self.name = name
    ...:
    ...:     def __getattr__(self, name):
    ...:         if hasattr(self, name):
    ...:             return 1
    ...:
    ...:     def __setattr__(self, name, value):
    ...:         print("调用 __setattr__()")
    ...:         self.__dict__[name] = value
    ...:
    ...:     def __delattr__(self, name):
    ...:         del self.__dict__[name]
    ...:

In [87]: o = O("tiger")
调用 __setattr__()

In [88]: print(hasattr(o, "name"))
True

In [89]: print(hasattr(o, "age"))
---------------------------------------------------------------------------
RecursionError                            Traceback (most recent call last)
<ipython-input-89-5f9010a5460d> in <module>
----> 1 print(hasattr(o, "age"))

<ipython-input-86-acdea0974859> in __getattr__(self, name)
      4
      5     def __getattr__(self, name):
----> 6         if hasattr(self, name):
      7             return 1
      8

... last 1 frames repeated, from the frame below ...

<ipython-input-86-acdea0974859> in __getattr__(self, name)
      4
      5     def __getattr__(self, name):
----> 6         if hasattr(self, name):
      7             return 1
      8

RecursionError: maximum recursion depth exceeded
```

另外，重写 `__getattr__()` 会影响到 `hasattr()` 的正确性，具体来说，只要重写了 `__getattr__()`，`hasattr()` 总会返回 `True`：

```python
In [140]: class O:
     ...:     def __init__(self, name):
     ...:         self.name = name
     ...:
     ...:     def __getattr__(self, name):
     ...:         print(1)
     ...:         pass
     ...:
     ...:
     ...: o = O("tiger")

In [141]: hasattr(o, "name")
Out[141]: True

In [142]: hasattr(o, "age") # 这里接收到的是 `__getattr__()` 返回的 None
1
Out[142]: True
```