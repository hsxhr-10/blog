# 变量

## What

变量是程序的基本成分（常量、变量、运算符、表达式、语句块、控制流、函数、类、抽象类、接口等）。变量有作用域、类型等重要特性。

## Why

有了最基本的变量，才能对现实世界的数据进行抽象，有了变量这个基本单元，才能构建出丰富多彩的程序。

## How

### 变量的查找顺序

局部变量（函数内、方法内）> 闭包变量 > 全局变量 > import > 内置变量 > 报错（找不到）

### 变量的作用域

1. 控制流语句（if、for、while）不会将全局变量变成局部变量
    ```python
    In [174]: x = 1

    In [175]: if True:
        ...:     print(x)
        ...:     x = 2
        ...:     print(x)
        ...:
    1
    2
    ```

2. 函数、类声明语句（`def`、`class`、`lambda`）可能会将全局变量变成局部变量
    ```python
    In [176]: x = 1

    In [177]: def foo():
        ...:     print(x)
        ...:     x = 2  # 对全局变量重新赋值，全局变量变成局部变量，可能会造成 referenced before assignment 的错误
        ...:     print(x)
        ...:

    In [178]: foo()
    ---------------------------------------------------------------------------
    UnboundLocalError                         Traceback (most recent call last)
    <ipython-input-178-c19b6d9633cf> in <module>
    ----> 1 foo()

    <ipython-input-177-15f508d05458> in foo()
        1 def foo():
    ----> 2     print(x)
        3     x = 2
        4     print(x)
        5

    UnboundLocalError: local variable 'x' referenced before assignment
    ```

    解决方法是在函数、类内使用全局变量时，用 `global` 关键字显式声明全局变量：
    ```python
    In [181]: x = 1

    In [182]: def foo():
        ...:     global x
        ...:     print(x)
        ...:     x = 2
        ...:     print(x)
        ...:

    In [183]: foo()
    1
    2
    ```

### 变量的类型

类型决定着可以存放什么样的数据，以及可以做哪些操作。一门语言所提供类型的丰富程度，很大程度上影响着开发效率，试想一下，Java 没了 util 包下的集合框架会是什么情景😂

#### 基本类型

- int：理论上可以代表任意大的整数，在和 C 混合编程时，可能会造成 C 的类型溢出
- float：同上
- bool：True/False, 1/0, 非空串/空串（注意可能要先用 `strip()` 做处理）, 非空集合/空集合（注意最好用 `if len(...) == 0` 来判断是否空集合）
- 字符串：Python2.x 的字符串是 str，Python3.x 的是 Unicode 容器，在用 Cython 时可能会有困扰

#### 复合类型

内置的：
    - list：底层数据结构是动态数组。应用场景：可以当列表、栈、队列来用，但是你懂的，动态数组嘛，优势在于尾部的增删和随机访问，其他用途就别想了，本来 Python 的性能就不够用
    - dict：底层数据结构待确定（TODO）。应用场景：任何适合键值对的场景
    - set：底层数据结构待确定（TODO）。应用场景：去重；集合运算
标准库：
    - collections
        - deque：底层数据结构待确定（TODO）。应用场景：任何适合双端队列的场景
        - OrderDict：底层数据结构待确定（TODO）。应用场景：有序的字典
        - Counter：底层数据结构待确定（TODO）。一个计数器，格式为 {key: 对应的统计个数}。应用场景：符合格式要求的 dict 之间的运算；字符串统计中每个单词个数统计等
    - queue：底层数据结构待确定（TODO）。应用场景：线程安全的先进先出队列、后进先出队列、优先队列
    - heapq：底层数据结构是二项堆。使用场景：优先队列

> 没特殊说明的都是线程不安全的

### 类型的可变性

Python 中不可变类型有：数值、字符串、tuple、frozenset。其余为可变类型。

可变类型在使用中存在陷阱：

```python
In [3]: def foo(l=[]):
   ...:     l.append(1)
   ...:     print(l)
   ...:

In [4]: foo()
[1]

In [5]: foo()
[1, 1]

In [6]: foo()
[1, 1, 1]

In [7]: foo()
[1, 1, 1, 1]
```

上面例子跟预期行为不一样，原因是函数参数的默认值属于可变类型，可变类型在默认值初始化时，只会初始化一次，而不是在每次被调用时重新初始化。

也可以通过 `__default__` 内置变量来观察到：

```python
def foo(l=[]):
    l.append(1)
    print(l)


In[297]: foo.__defaults__
Out[297]: ([],)

In[298]: foo()
[1]

In[299]: foo.__defaults__
Out[299]: ([1],)

In[300]: foo()
[1, 1]

In[301]: foo.__defaults__
Out[301]: ([1, 1],)

In[302]: foo()
[1, 1, 1]

In[303]: foo.__defaults__
Out[303]: ([1, 1, 1],)
```

因此，为可变类型指定默认参数时，应该使用 `None`：

```python
n [10]: def foo(l=None):
    ...:      if l is None:
    ...:           l = []
    ...:      l.append(1)
    ...:      print(l)
    ...:

In [11]: foo()
[1]

In [12]: foo()
[1]

In [13]: foo()
[1]

In [14]: foo()
[1]
```