# 基础类型

## 整型

### 整型指的定义

整型指的是负整数、0、正整数。Python2.x 会用 `long` 类型来存储大整型，而 Python3.x 只用 `int` 一种类型存储整型，无论大小

### 不同进制的整型表示法

- 二进制 0b...，转换函数是 `bin()`
- 八进制 0o...，转换函数是 `oct()`
- 十六进制 0x...，转换函数是 `hex()` 

### 用分隔符增强可读性

从 Python3.x 开始支持用 `_` 来分割很长的整型，增加可读性，如：`a = 1_000_000_000_000_000_000_000`

### 更进一步

#### 小整型对象

Python 中的 int 其实也是一个对象，对应一个 C 的数据结构，而且 Python 的所有对象都是在堆上，也就是说，理论上只要创建一次
整型，就需要相应的 `malloc` 和 `free`，这些操作如果过于频繁会降低程序的效率。对于 [-5, 257) 这个范围的小整型，
Python 的设计者们考虑到它们可能会被频繁的使用，因此，Python 运行时会在一开始就创建好这些整型数字对应的对象，并且放到一个缓存池中，
每次需要的时候，再从池中获取，以此来减少 `malloc`、`free`、Python 对象的回收的次数，提升 Python 的整体性能（虽然 Python 的性能老被吐槽，但是这些优化细节还是不少的。这也是为整型的 ID 都一样的原因）

#### 大整型对象 

因为不可能为每一个整型都预先创建好对象，所以不在 [-5, 257) 这个范围的整型并不会预先创建。Python 对大整型对象的优化方法是预先划分出一块内存空间，
专门用于大整型对象，也就是说，虽然不能预先创建好，但是内存池该上还是上了

## 浮点型

### 浮点型的计算

由于小数点后的部分在转换成二进制时很可能会是一串无限循环的小数，因此导致不能精准表示，所以浮点的计算一般是不精确的

案例：

```bash
In [91]: a = 0.29

In [92]: b = 0.29 * 100

In [93]: c = int(b)

In [94]: c
Out[94]: 28
```

显然不是预期的结果

#### 转换成分数计算

使用 fractions 模块将小数运算转换成分数运算

```bash
In [112]: from fractions import Fraction

In [113]: a = Fraction(29) / Fraction(100)
In [114]: b = a * 100
In [115]: c = int(b)

In [116]: c
Out[116]: 29
```

#### 转换成定点数运算

使用 decimal 模块进行浮点型运算

```bash
In [117]: from decimal import Decimal

In [118]: a = Decimal("0.29")
In [119]: b = a * 100
In [120]: c = int(b)

In [121]: c
Out[121]: 29
```

decimal 还可以指定结果保留的个数，默认四舍五。分两种情况，当结果小数点前非 0 时，保留的个数包括整数位的个数，如下：

```BASH
In [130]: import decimal
     ...:
     ...: decimal.getcontext().prec = 5
     ...:
     ...:
     ...: division = decimal.Decimal(77) / decimal.Decimal(3)
     ...: print(division)
25.667
```

当小数点前是 0 时，结果保留个数只包括小数位的个数，如下：

```BASH
In [4]: import decimal

In [5]: decimal.getcontext().prec = 5
In [6]: division = decimal.Decimal(1) / decimal.Decimal(3)

In [7]: print(division)
0.33333
```

### round() 的陷阱

案例：

```BASH
In [46]: round(11.485, 2)
Out[46]: 11.48
```

预期结果是 11.49。原因是当小数的末尾是 5，而 `round()` 刚好使用末尾的 5 进行四舍五入时，将不会进行「五入」

可以使用 decimal 模块修复这种问题，如下： 

```BASH
In [1]: import decimal

In [2]: res = round(13.485, 2)
In [3]: correct_res = decimal.Decimal(res).quantize(decimal.Decimal('0.00'), rounding=decimal.ROUND_UP)

In [4]: print(correct_res)
13.49
```

## 布尔类型

### 判断容器是否为空

比较 Pythonic 的写法是：

```python
lst = []
if not lst:
    print("list is empty")  
```

显式写法是：

```python
lst = []
if len(lst) == 0:
    print("list is empty")
```

## 字符串类型

## 字节数组类型

### 字节数组类型的定义

`bytes` 是指存储单元是字节的数组，是 Python3.x 新增的类型，除了存储单元不同之外，和 `str` 所支持的操作基本上是一样的

### 编码和解码

字符集的作用：地球上有很多语言，这些语言需要中间映射表，用来将现实世界中的语言映射成相应的字节，这个映射表就是字符集。
一开始各自为战，每种语言都有一个字符集，后来为了解决不同语言之间的编码问题，发展出统一的字符集，可以囊括世界上绝大部分的语言，
比如 UTF-8 就是其中一种，在 UTF-8 中一个英文字符等于一个字节，一个中文等于三个字节。

`str`、`bytes`、二进制之间的转换关系如下：

![]()

