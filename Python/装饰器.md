# 装饰器

## What

函数式编程的一种应用，本质是将函数视为普通参数进行传递，Python 在语法层面做出支持。

## Why

语法糖。

## How

### 装饰器执行顺序

```python
def wrapper_out1(func):
    print('--out11--')

    def inner1(*args, **kwargs):
        print("--in11--")
        ret = func(*args, **kwargs)
        print("--in12--")
        return ret
    print("--out12--")
    return inner1


def wrapper_out2(func):
    print('--out21--')

    def inner2(*args, **kwargs):
        print("--in21--")
        ret = func(*args, **kwargs)
        print("--in22--")
        return ret
    print("--out22--")
    return inner2


@wrapper_out2
@wrapper_out1
def test():
    print("--test--")
    return 1 * 2


if __name__ == '__main__':
    test()
```

上述代码的输出结果是：

```bash
--out11--
--out12--
--out21--
--out22--
--in21--
--in11--
--test--
--in12--
--in22--
```

个人总结了个简单的方法来判断这种疯狂套娃的情况（TODO）：

1. 先根据装饰器本质就是函数传递，写出套娃的简化版 wrapper_out2(wrapper_out1(test))
2. 根据简化版，写出套娃的详细版，如下图
    ![]()
3. 由内而外，执行装饰器 inner 之外的部分，如下图
    ![]()
4. 完成 3 之后，再按顺序从上到下执行语句即可，如下图
    ![]()

不过实际使用时应该要要避免写得这么复杂，而且要制订好具体规则。比如用装饰器解耦代码时，约定好只在 inner 函数的内部且上面的部分编写额外逻辑代码，然后想先执行的装饰器放上面就可以了。

### functools.wraps 用途

解决装饰器的副作用，将装饰器的 __name__、__doc__ 等内置变量改成被装饰函数的。

### 使用场景

1. 无参数的装饰器
    ```python
    import functools


    def wrapper(f):
        @functools.wraps(f)
        def inner(*args, **kwargs):
            return f(*args, **kwargs)
        return inner


    @wrapper
    def test(name):
        print('name: {}'.format(name))


    if __name__ == '__main__':
        test('tiger')

    # name: tiger
    ```

2. 带参数的装饰器
    ```python
    import functools


    def decorator(age):
        def wrapper(f):
            @functools.wraps(f)
            def inner(*args, **kwargs):
                print('age: {}'.format(age))
                return f(*args, **kwargs)
            return inner
        return wrapper


    @decorator(age=23)
    def test(name):
        print('name: {}'.format(name))


    if __name__ == '__main__':
        test('tiger')

    # age: 23
    # name: tiger
    ```

3. 解耦业务逻辑
    ```python
    import functools


    def auth(f):

        @functools.wraps(f)
        def inner(*args, **kwargs):
            print('auth done.')
            return f(*args, **kwargs)
        return inner


    def login(f):

        @functools.wraps(f)
        def inner(*args, **kwargs):
            print('login done.')
            return f(*args, **kwargs)
        return inner


    @auth
    @login
    def test(name):
        print('I am {}'.format(name))


    if __name__ == '__main__':
        test('tiger')

    # auth done.
    # login done.
    # I am tiger
    ```

4. 缓存函数的运算结果
    ```python
    import functools


    def cache(f):
        @functools.wraps(f)
        def inner(*args, **kwargs):
            inner.total += 1
            print('total: {}'.format(inner.total))
            return f(*args, **kwargs)

        inner.total = 0
        return inner


    @cache
    def test(name):
        print('I am {}'.format(name))


    if __name__ == '__main__':
        test('tiger')
        test('tiger')
        test('tiger')

    # total: 1
    # I am tiger
    # total: 2
    # I am tiger
    # total: 3
    # I am tiger
    ```

5. 实现单例模式
    ```python
    import functools


    def single(cls):
        @functools.wraps(cls)
        def inner(*args, **kwargs):
            if inner.obj is None:
                inner.obj = cls(*args, **kwargs)
                print('create object instance {}.'.format(inner.obj))
            return inner.obj
        
        inner.obj = None
        return inner


    @single
    class Test(object):
        def __init__(self, name):
            super().__init__()
            self.name = name


    if __name__ == '__main__':
        Test('tiger')
        Test('tiger')
        Test('tiger')

    # 只会输出一次：create object instance <__main__.Test object at 0x10c7f4f28>.
    ```

6. 函数执行耗时记录器
    ```python
    import functools
    import time


    def timer(f):
        @functools.wraps(f)
        def inner(*args, **kwargs):
            start = time.time()
            r = f(*args, **kwargs)
            end = time.time()
            print("Function=%s, Time=%s" % (f.__name__, end - start))
            return r
        return inner
    ```