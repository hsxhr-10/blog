# 装饰器

将函数作为参数进行传递，函数式编程的一种体现，装饰器本质就是这么回事，Python 将其作为语法层面的支持。

## 装饰器执行顺序

敢问下面这个程序的输出是什么：

```python
def wrapper_out1(func):
    print('--out11--')

    def inner1(*args, **kwargs):
        print("--in11--")
        ret = func(*args, **kwargs)
        print("--in12--")
        return ret
    print("--out12--")
    return inner1


def wrapper_out2(func):
    print('--out21--')

    def inner2(*args, **kwargs):
        print("--in21--")
        ret = func(*args, **kwargs)
        print("--in22--")
        return ret
    print("--out22--")
    return inner2


@wrapper_out2
@wrapper_out1
def test():
    print("--test--")
    return 1 * 2


if __name__ == '__main__':
    test()
```

答案是：

```bash
--out11--
--out12--
--out21--
--out22--
--in21--
--in11--
--test--
--in12--
--in22--
```

个人总结了个简单的方法来判断这种疯狂套娃的情况：

1. 先根据装饰器本质就是函数传递，写出套娃的简化版 wrapper_out2(wrapper_out1(test))
2. 根据简化版，写出套娃的详细版，如下图
    ![]()
3. 由内而外，执行装饰器 inner 之外的部分，如下图
    ![]()
4. 完成 3 之后，再按顺序从上到下执行语句即可，如下图
    ![]()

不过一般实际使用不会想上面例子那么复杂，比如当用于解耦业务代码时，只要约定好只在 inner 的外部且上面的部分编写额外的代码，然后执行优先级越高的装饰器放在越里面即可。比如下面「使用场景」中解耦业务逻辑的例子。

## functools.wraps

用途：解决装饰器的副作用，即将装饰器的 __name__、__doc__ 等内置变量改成被装饰函数的值。

## 装饰器常见的使用场景

无参数的装饰器：

```python
import functools


def wrapper(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        return f(*args, **kwargs)
    return inner


@wrapper
def test(name):
    print('name: {}'.format(name))


if __name__ == '__main__':
    test('tiger')

# name: tiger
```

带参数的装饰器：

```python
import functools


def decorator(age):
    def wrapper(f):
        @functools.wraps(f)
        def inner(*args, **kwargs):
            print('age: {}'.format(age))
            return f(*args, **kwargs)
        return inner
    return wrapper


@decorator(age=23)
def test(name):
    print('name: {}'.format(name))


if __name__ == '__main__':
    test('tiger')

# age: 23
# name: tiger
```

解耦业务逻辑：

```python
import functools


def auth(f):
    print('auth done.')

    @functools.wraps(f)
    def inner(*args, **kwargs):
        return f(*args, **kwargs)
    return inner


def login(f):
    print('login done.')

    @functools.wraps(f)
    def inner(*args, **kwargs):
        return f(*args, **kwargs)
    return inner


@login
@auth
def test(name):
    print('I am {}'.format(name))


if __name__ == '__main__':
    test('tiger')

# auth done.
# login done.
# I am tiger
```

缓存函数的运算结果：

```python
import functools


def cache(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        inner.total += 1
        print('total: {}'.format(inner.total))
        return f(*args, **kwargs)

    inner.total = 0
    return inner


@cache
def test(name):
    print('I am {}'.format(name))


if __name__ == '__main__':
    test('tiger')
    test('tiger')
    test('tiger')

# total: 1
# I am tiger
# total: 2
# I am tiger
# total: 3
# I am tiger
```

实现单例模式：

```python
import functools


def single(cls):
    @functools.wraps(cls)
    def inner(*args, **kwargs):
        if inner.obj is None:
            inner.obj = cls(*args, **kwargs)
            print('create object instance {}.'.format(inner.obj))
        return inner.obj
    
    inner.obj = None
    return inner


@single
class Test(object):
    def __init__(self, name):
        super().__init__()
        self.name = name


if __name__ == '__main__':
    Test('tiger')
    Test('tiger')
    Test('tiger')

# 只会输出一次：create object instance <__main__.Test object at 0x10c7f4f28>.
```

函数执行耗时记录器：

```python
import functools
import time


def timer(f):
    @functools.wraps(f)
    def inner(*args, **kwargs):
        start = time.time()
        r = f(*args, **kwargs)
        end = time.time()
        print("Function=%s, Time=%s" % (f.__name__, end - start))
        return r
    return inner
```