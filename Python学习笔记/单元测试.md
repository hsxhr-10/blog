# 单元测试

- [测试框架提供的断言方法](https://docs.python.org/3/library/unittest.html#assert-methods)
- `setUp()` 和 `tearDown()` 会在每个测试案例执行的前后执行
- 自定义测试套件（执行哪些测试案例, 以及执行顺序）
    ```Python
    def suite():
        suite = unittest.TestSuite()
        suite.addTest(HouseTestCase('test_0_house_owner_setter'))
        suite.addTest(HouseTestCase('test_0_house_owner_getter'))
        return suite
    
    
    if __name__ == '__main__':
        runner = unittest.TextTestRunner()
        runner.run(suite())
    ```
- 跳过某个测试案例：`@unittest.skip("skipping")`
- mock：单元测试应该只针对当前单元进行测试, 所有的外部依赖应该是稳定的, 在别处进行测试过的
    ```Python
    # mock 掉外部依赖的 MySQL, 返回 mock 数据 [12, 32, 43, 74, 25, 16, 77, 89, 90]
    self.house.query_mysql = MagicMock(return_value=[12, 32, 43, 74, 25, 16, 77, 89, 90])
    ```
- Coverage：https://coverage.readthedocs.io/en/latest/#quick-start

如果只是一个简单的脚本，那大概率不需要单元测试，但是如果是一个逻辑比较多的中大型项目，需要不断迭代修改的，单元测试就可以很好地保护我们的项目，
它可以将我们的项目代码「固定起来」，避免新的迭代误修改了旧的逻辑而不自知，从而让我们对每一次更新发布都更有信心。

Python 标准库提供的 `unittest` 已经很好用了，配合少量第三方库，足以搭建起一套测试框架来保证我们的代码质量

## 基本用法

待测试代码 `demo1.py`：

```Python
class House:
    def __init__(self, owner, worth):
        self.__owner = owner
        self.__worth = worth
        self.__peoples = []

    @property
    def owner(self):
        return self.__owner

    @owner.setter
    def owner(self, _owner):
        self.__owner = _owner

    @property
    def worth(self):
        return self.__worth

    @worth.setter
    def worth(self, _worth):
        if _worth < 0:
            return
        self.__worth = _worth

    @property
    def peoples(self):
        return self.__peoples

    @peoples.setter
    def peoples(self, name):
        if name not in self.__peoples:
            self.__peoples.append(name)
```

单元测试代码 `demo2.py`：

```Python
import unittest

from demo1 import House


class HouseTestCase(unittest.TestCase):
    def setUp(self):
        self.house = House("yoko", 123456789)

    def tearDown(self):
        del self.house

    def test_0_house_owner_getter(self):
        self.assertEqual(self.house.owner, "yoko")

    def test_0_house_owner_setter(self):
        self.house.owner = "tiger"
        self.assertEqual(self.house.owner, "tiger")

    def test_0_house_worth_getter(self):
        self.assertEqual(self.house.worth, 123456789)

    def test_0_house_worth_setter(self):
        self.house.worth = 999999999
        self.assertEqual(self.house.worth, 999999999)

    def test_1_house_worth_setter(self):
        """
        测试 @worth.setter 中的分支情况.

        注意: 虽然在 test_0_house_worth_setter() 中将 self.house.worth 改成了 999999999, 但是每个测试案例是相互独立的,
             也就是说在 test_1_house_worth_setter() 中 self.house 仍然为 setUp() 时设定的值 123456789.
        """
        self.house.worth = -1
        self.assertEqual(self.house.worth, 123456789)

    def test_0_house_peoples_getter(self):
        self.assertEqual(self.house.peoples, [])

    def test_0_house_peoples_setter(self):
        self.house.peoples = "tiger"
        self.house.peoples = "yoko"
        self.house.peoples = "wade"
        self.house.peoples = "simon"
        self.assertEqual(self.house.peoples, ["tiger", "yoko", "wade", "simon"])


if __name__ == "__main__":
    unittest.main(verbosity=2)
```

运行：

```bash
(lab) tmp ➤ python demo2.py                                                                                                                                                                                                                                                                                          
test_0_house_owner_getter (__main__.HouseTestCase) ... ok
test_0_house_owner_setter (__main__.HouseTestCase) ... ok
test_0_house_peoples_getter (__main__.HouseTestCase) ... ok
test_0_house_peoples_setter (__main__.HouseTestCase) ... ok
test_0_house_worth_getter (__main__.HouseTestCase) ... ok
test_0_house_worth_setter (__main__.HouseTestCase) ... ok
test_1_house_worth_setter (__main__.HouseTestCase) ... ok

----------------------------------------------------------------------
Ran 7 tests in 0.001s

OK
```

