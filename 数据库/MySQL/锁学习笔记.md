# 锁学习笔记

1. 锁的作用
2. 锁的类型（如何上锁）
3. 一些关键的概念
4. 行锁实现方法
5. 加锁分析（和实验）
6. 死锁
7. 排查锁的问题
8. 乐观锁和悲观锁

读操作：SELECT
写操作：INSERT，UPDATE，DELETE

表锁加锁规则：
- 读锁
    - 自身读操作正常，自身写操作会报错
    - 其他读操作正常，其他写操作会阻塞
- 写锁
    - 自身读操作正常，自身写操作正常
    - 其他读操作会阻塞，其他写操作会阻塞

行锁加锁规则：
- 读锁
    - 自身事务读操作正常，自身事务写操作正常
    - 其他事务读操作正常，其他事务写操作会阻塞
- 写锁
    - 自身事务读操作正常，自身事务写操作正常
    - 其他事务读操作正常（简单的读操作走 MVCC 快照读，加锁的读操作阻塞），其他事务写操作会阻塞

为什么上了写锁，别的事务还可以读操作？
因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

select * from information_schema.INNODB_LOCKS;

- 同一个事务加的 `GAP LOCK` 是可以插入的
- 多用唯一联合索引

S-共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。
X-排他锁: 又叫写锁，一旦加了写锁之后，其他事务就不能加锁了

---

在计算机系统中，多个进程或者多个线程并发访问一个共享资源时，都需要锁的保护，数据库也不例外。在数据库中，除了 CPU/MEM/IO 这些
由操作系统管控的共享资源外，数据也是一种会被并发事务访问的共享资源，数据库的锁就是用来保护这些数据一致性和有效性的工具

数据库的锁有粒度大小之分，粒度越大，锁冲突发生的概率就越大，并发性能越低。同时锁的各种操作（检测锁、获取锁、释放锁等）都会消耗系统资源

下面可能会对一些概念进行验证，运行的系统环境是：

- Ubuntu 18.04 LTS
- MySQL 5.7.33
- 测试数据是 [employees.sql](https://github.com/datacharmer/test_db)

> 以下的读操作指的是 `SELECT`，写操作指的是 `INSERT`|`UPDATE`|`DELETE`

## 锁的类型

MySQL 提供了表锁和行锁两种大的锁类型。表锁由 MySQL 服务器实现，无论你的存储引擎是什么都能使用表锁，而行锁是由特定的存储引擎实现，比如 InnoDB 默认是用行锁，
参考 [这个](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%A6%82%E8%BF%B0.md#%E6%9E%B6%E6%9E%84%E6%A6%82%E5%86%B5)

行锁和表锁的对被如下：

- 表锁：开销少，加锁快，不会出现死锁，锁的粒度大，发生锁冲突的概率高，并发程度低
- 行锁：开销大，加锁慢，会出现死锁，锁的粒度小，发生锁冲突的概率低，并发程度高

## 表锁

表锁是指对一整张表加锁，一般是 DDL 处理时使用，但是也可以在 DML 中手动指定。表锁又可以细分为读锁和写锁两种

### (1)重要的特性

- MyISAM 只能使用表锁，在 MyISAM 下，读操作默认上读锁，写操作默认上写锁

### (2)手动上锁

读锁：

```SQL
lock table <table_name1> read, <table_name2> read, ...;
<some_sql>
unlock tables;
```

写锁：

```SQL
lock table <table_name1> write, <table_name2> write, ...;
<some_sql>
unlock tables;
```

### (3)读锁的语法

1. 持有读锁的会话可以读操作，但不能写操作，会报错，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-5.png)
2. 允许多个会话同时申请、持有读锁，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-6.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-7.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-8.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-9.png)
3. 没有持有读锁的会话也能读操作，但是不能写操作，会被阻塞，直到读锁被释放，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-10.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-11.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-12.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-13.png)
4. 如果读锁还没释放，其他会话试图申请写锁时，会被阻塞，直到读锁被释放，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-14.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-15.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-16.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-17.png)

**🌟 表锁的读锁语法小结：对于加了读锁的会话，会阻塞任何会话（包括持有读锁的会话本身，自身不会阻塞，会直接报错）
对于同一个表的写操作或者申请写锁的操作，直到锁被释放**

### (4)写锁的语法

1. 持有写锁的会话既可以读操作，也可以写操作
2. 如果写锁还没释放，其他会话既不可以读操作，也不可以写操作，会被阻塞，直到写锁被释放
3. 如果写锁还没释放，其他会话既不可以申请读锁，也不可以申请写锁，会被阻塞，直到写锁被释放

**🌟 表锁的写锁语法小结：对于加了写锁的会话，会阻塞其他会话对于同一个表的任何操作（读写操作、申请锁的操作），直到锁被释放**

### (5)锁的释放时机

1. 使用 `UNLOCK TABLES` 手动释放
2. 如果会话在持有锁的情况下再次执行 `LOCK TABLE`，之前持有的锁将会被释放
3. 如果会话在持有锁的情况下执行 `BEGIN` 开启事务，之前持有的锁将会被释放
4. 如果断开连接，之前锁持有的锁将会被释放

### (6)一次性封锁

表锁使用的是一次性封锁原则，也就是说一个会话一旦加了锁，在释放锁、或者重新加锁之前，都只能操作加锁的表，验证 ✅

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-18.png)

## 行锁

行锁泛指加在索引列上的锁，索引结构可以参考 [这里](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84) 。 
行锁一般用于事务里的 DML 操作。行锁又可以细分为 `Record-Lock`（记录锁）、`Gap-Lock`（间隔锁）、`Next-Key-Lock`（记录锁加间隔锁）、`LOCK_INSERT_INTENSION`（插入意向锁，插入记录时使用，是间隔锁的一种特例）

### (1)重要的特性

- InnoDB 默认（RR 隔离级别）使用的是行锁，具体来说是 `Next-Key-Lock`，只有在没有索引或者索引失效的情况下，才会退化成对所有记录列加 `Next-Key-Lock`，
  类似锁表了；如果索引是唯一索引（包括主键索引），`Next-Key Lock` 会升级成 `Record-Lock`
- InnoDB 下的读操作是快照读，默认不加锁（但是也可以手动上锁），对于写操作默认加写锁
- 如果非聚簇索引会引发 [回表](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95) ，
  那么回表也将会影响到加锁的操作，具体来说就是二级索引的索引记录会被上锁，对应的聚簇索引记录也会被上锁，如下图所示：
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-19.png)
- MySQL 的加锁步骤是按照查询结果一条条加的，比如 `update students set level = 3 where score >= 60;` 查询出来 100 条，而且 score 是二级索引，
  那么理论上就要进行 200 次的加锁操作
- 行锁下面的四种锁模式都有读锁和写锁之分
- 间隔锁之间不会发生冲突
- 二级索引 next-key-lock 回表，聚簇索引只加记录锁
- 二级索引间隔锁回表，聚簇索引不加锁

### (2)手动上锁

- 读锁：
  ```SQL
  SELECT ... LOCK IN SHARE MODE;
  ```
- 写锁：
  ```SQL
  SELECT ... FOR UPDATE;
  ```

### (3)读锁的语法

验证 ✅

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-20.png)
![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-21.png)

**🌟 行锁的读锁语法小结：对于加了读锁的事务，会阻塞其他事务对于同一行数据的写操作或者申请写锁的操作，直到锁被释放**

### (4)写锁的语法

验证 ✅

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-22.png)
![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-23.png)

**🌟 行锁的写锁语法小结：对于加了写锁的事务，会阻塞其他事务对于同一行数据的写操作或者申请读、写锁的操作，直到锁被释放**

> 表锁是会话和同一个表之间的作用关系，行锁是事务和同一行数据之间的作用关系

### (5)锁的释放时机

1. 提交事务
2. 回滚事务
3. 阻塞的事务进程被 kill

### (6) 行锁的四种模式

#### (1)记录锁

记录锁加在索引记录列上，索引结构可以参考 [这里](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84) 。
一般在遇到主键索引、唯一索引时会使用记录锁

案例：`UPDATE accounts SET level = 100 WHERE id = 5;`，假设 id 是主键

- 上写锁，而且是记录锁

#### (2)间隔锁

间隔锁加在两个索引之间、或者某个索引列之前、或者某个索引列之后。间隔锁是用来配合插入意向锁一起防止 [幻读](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB) 的发生，
间隔锁之间不会发生冲突。

案例：如果有两个索引列 a 和 b，它们之间可能的间隔锁如下

- (-∞, a)
- (a, b) 
- (b, +∞)

#### (3)Next-Key-Lock

Next-Key-Lock 是记录锁和间隔锁的组合，是 InnoDB 默认使用的行锁模式。

案例：`UPDATE accounts SET level = 100 WHERE name = 'z'';`，name 不是主键和唯一索引

- 上写锁，而且是 Next-Key-Lock
- name='z' 对应的索引列加记录锁
- name='z' 对应的索引列的前后加间隔锁
- 回表的聚簇索引对应的索引列加记录锁

假设 name 加的是主键索引或者唯一索引，就不是加 Next-Key-Lock 而是加记录锁，因为 name 已经是唯一的，在想插入一个 name='z' 是不可能的，
也就是说不会发生幻读，所以就没必要加间隔锁了。这也是江湖流传的多用主键索引，或者多用唯一索引的原因了

> 如果幻读造成的影响无关痛痒，可以将事务的隔离级别从默认的 RR 降到 RC，可以避免间隔锁造成的死锁

#### (4)插入意向锁

插入意向锁是一种特殊的间隔锁，插入意向锁之间也不会冲突，插入意向锁只会和间隔锁冲突。只有在 `INSERT` 的时候才会用到这个锁，每当想要插入时，
先尝试上一个插入意向锁，如果要插入的位置已经加了间隔锁，插入就失败，幻读也就被阻止了

注意：表锁也有意向锁，但是跟插入意向锁不是一回事（读意向锁 IS 和写意向锁 IX，功能和表锁中的读锁、写锁大致相同），前者是用来快速检测某个表是否上了行锁
（不用一行行遍历），以及上的是哪种行锁、哪种表锁。比如，事务 T1 对表 A 上了一个行锁写锁，也就是默认对表 A 上了 IX，
其他会话就可以快速得知是否有上行锁， 同时其他会话想要对表 A 上表锁时就会被阻塞，无论是表锁读锁还是表锁写锁

## 观察行锁

一般有两种方法观察锁等待，第一种是 `select * from information_schema.innodb_locks;`，第二种看是 `show engine innodb status;`
的 `TRANSACTIONS` 部分

### 记录锁

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-24.png)
![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-25.png)
![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-26.png)

### 间隔锁和 Next-Key-Lock

因为间隔锁一般会跟 Next-Key-Lock 一起出现，所以这里把它们放在一起演示

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-27.png)
![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-28.png)
![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-29.png)

## SQL 加锁分析

### 步骤

1. 对一条 SQL 进行加锁分析，需要先确定：
    - 事务隔离级别（RR 有间隔锁、RC 没有间隔锁）
    - 是否用到索引（没用到索引的全表记录加 next-key-lock）
    - 查询是否命中（没命中的 RR 下加间隔锁）
    - `WHERE` 语句的判断符号（范围运算符的加锁范围比等号运算符大得多）
2. 确定索引类型（聚簇索引、二级唯一索引、二级非唯一索引）
3. 确定锁的类型（表锁还是行锁），读锁还是写锁，锁的模式（记录锁、间隔锁、next-key-lock、插入意向锁）
4. 确定是否需要回表（二级索引需要回表），回表需要加哪种锁（记录锁回表加记录锁、间隔锁回表不用加、next-key-lock 回表加记录锁）

### 练习案例

- 聚簇索引，查询命中：UPDATE students SET score = 100 WHERE id = 15;
- 聚簇索引，查询未命中：UPDATE students SET score = 100 WHERE id = 16;
- 二级唯一索引，查询命中：UPDATE students SET score = 100 WHERE no = 'S0003';
- 二级唯一索引，查询未命中：UPDATE students SET score = 100 WHERE no = 'S0008';
- 二级非唯一索引，查询命中：UPDATE students SET score = 100 WHERE name = 'Tom';
- 二级非唯一索引，查询未命中：UPDATE students SET score = 100 WHERE name = 'John';
- 无索引：UPDATE students SET score = 100 WHERE score = 22;
- 聚簇索引，范围查询：UPDATE students SET score = 100 WHERE id <= 20;
- 二级索引，范围查询：UPDATE students SET score = 100 WHERE age <= 23;
- 修改索引值：UPDATE students SET name = 'John' WHERE id = 15;

参考答案：

- 聚簇索引-行锁-写锁-记录锁
- 聚簇索引-行锁-写锁-间隔锁
- 二级唯一索引-行锁-写锁-记录锁，聚簇索引-写锁-记录锁
- 二级唯一索引-行锁-写锁-间隔锁
- 二级非唯一索引-行锁-写锁-next，聚簇索引-写锁-记录锁
- 二级非唯一索引-行锁-写锁-间隔锁
- 全表记录加 next
- 聚簇索引-行锁-写锁-next
- 二级非唯一索引-行锁-写锁-next，聚簇索引-写锁-记录锁
- 二级非唯一索引-行锁-写锁-记录锁（SET 的字段），聚簇索引-写锁-记录锁

## 乐观锁和悲观锁

乐观锁和悲观锁不是具体的锁类型，而是一种锁思想。悲观锁指的是主动上锁的方式，乐观锁指的是带条件的 `UPDATE` 语句的方式，也就是说，
悲观锁是通过数据库提供的锁机制来实现，乐观锁是通过应用程序端来实现，乐观锁适用于读多写少、冲突很少发生的场景，常见的实现方式有版本号控制和 CAS 算法

### 用版本号控制来实现乐观锁的流程

譬如有商品表，每次下单后库存减 1

1. product 表每行记录都增加一个 version 字段，每次更新都会加 1
2. 查询某个商品的库存和版本号，`SELECT stock, version FROM product WHERE id=100;`
3. 判断 stock 是否足够，足够则下单 `if (stock >= n)`，否则做相应处理
4. 更新库存的值，`new_stock = stock - n;`
5. 更新版本号的值，`new_version = version + 1;`
6. 更新库存和版本号，`UPDATE product SET stock=new_stock, version=new_version FROM product WHERE id=100 AND version=old_version;`
7. 如果更新失败，可以进行重试

### 案例

假设 id=100 的商品库存是 100，有两个线程并发下单，线程 A 买了 50 个商品，线程 B 买了 10 个商品

1. 线程 A 查询得到当前库存 100 和当前版本号 1
2. 线程 B 查询也得到当前库存 100 和当前版本号 1
3. 线程 A 更新库存为 50，更新版本号为 2，并执行 `UPDATE product SET stock=50, version=2 FROM product WHERE id=100 AND version=1;`，更新成功
4. 线程 B 更新库存为 90，更新版本号为 2，并执行 `UPDATE product SET stock=90, version=2 FROM product WHERE id=100 AND version=1;`，
    由于线程 A 已经将 version 更新成 2 了，所以线程 B 的 `WHERE` 条件不成立，更新失败，也就避免了线程 B 对线程 A 写入的覆盖
5. 线程 B 可以进行重试，也就是重新走上述的流程，如果顺利的话，线程 B 将会执行 `UPDATE product SET stock=40, version=3 FROM product WHERE id=100 AND version=2;` 来完成更新

## 排查死锁

### 排查步骤

1. 确保开启死锁日志、binlog
2. 通过死锁日志初步了解涉及的事务有哪些（一般是会有两个事务）、事务持有的锁是什么、等待的锁是什么、相关的 SQL 是什么（只保存事务阻塞前执行的那一条）
3. 通过死锁日志中死锁发生的时间，或者 SQL，到 binlog 中找到其中一个事务的完整 SQL（注意，只有提交了的事务才会记录到 binlog，回滚的不会被记录，所以一般只会有一个阻塞事务的完整 SQL 被记录）
4. 根据这一组完整的 SQL 到应用代码中找到相关的逻辑，结合死锁日志中另一个事务的 SQL，一般就可以推理出另一个事务在哪里
5. 尝试重现死锁的发生，并根据实际情况解决

### 死锁日志

#### 获取死锁日志的方法

第一种方法：

```SQL
show engine innodb status\G;
```

这种方法只能获取最近一次的死锁信息。

第二种方法：

```SQL
-- 开启标准监控
set GLOBAL innodb_status_output=ON;
-- 关闭标准监控
set GLOBAL innodb_status_output=OFF;
-- 开启锁监控
set GLOBAL innodb_status_output_locks=ON;
-- 关闭锁监控
set GLOBAL innodb_status_output_locks=OFF;
```

这种方法可以实时监控并记录所有死锁信息，写入 MySQL 的 stderr 日志，通过 `show variables like "%log_error%";` 可以找到日志的路径。
这种方法每隔 15s 会记录一次信息，对性能有消耗，建议只在排查时使用，平时关闭

第三种方法：

```SQL
-- 这个参数专门用来记录死锁信息
set GLOBAL innodb_print_all_deadlocks=ON;
```

这种方法也是实时监控并记录所有死锁信息，写入 MySQL 的 stderr 日志，相对第二种，只在死锁发生时记录，性能消耗更低，比较推荐

#### 读懂死锁日志

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-30.png)

死锁日志中对四种锁模式的文字描述：

- 记录锁：lock_mode X locks rec but not gap
- 间隙锁：lock_mode X locks gap before rec
- next-key-lock：lock_mode X
- 插入意向锁：lock_mode X locks gap before rec insert intention

### binlog

#### 开启 binlog

改一下配置文件就行，可以参考 [这里](https://blog.csdn.net/king_kgh/article/details/74800513)

#### 获取 binlog

binlog 一般可以叫运维导出，有权限的也可以自己用命令 `sudo mysqlbinlog -h <hostname> -u <user_name> -p --read-from-remote-server <binlog_file> --base64-output=decode-rows -v` 导出

#### 读懂 binlog

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-31.png)

## 预防死锁

- 尽量以固定的顺序访问表和行，交叉访问容易造成死锁回路
- 尽量避免大事务，一个事务中的锁越多，死锁发生的概率会越高
- 如果幻读对业务造成的影响可以接受，可以将事务隔离级别从 RR 调成 RC
- 尽量都用上索引，避免整个表的所有记录列被加上 next-key-lock
- 设置锁等待超时参数 `innodb_lock_wait_timeout`，当超时之后 MySQL 会选择代价较小的事务进行回滚

## 参考

- [为什么开发人员必须要了解数据库锁？](https://mp.weixin.qq.com/s/yzXbbutzVJ1hIZgVszIBgw)
- [MySQL死锁系列-线上死锁问题排查思路](https://cloud.tencent.com/developer/article/1722416)
- [开启 MySQL 的 binlog 日志](https://blog.csdn.net/king_kgh/article/details/74800513)
- [Mysql事务和锁（四） 死锁](https://www.zbpblog.com/blog-208.html)
