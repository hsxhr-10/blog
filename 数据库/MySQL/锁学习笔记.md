# 锁学习笔记

1. 锁的作用
2. 锁的类型（如何上锁）
3. 一些关键的概念
4. 行锁实现方法
5. 加锁分析（和实验）
6. 死锁
7. 排查锁的问题
8. 乐观锁和悲观锁

读操作：SELECT
写操作：INSERT，UPDATE，DELETE

表锁加锁规则：
- 读锁
    - 自身读操作正常，自身写操作会报错
    - 其他读操作正常，其他写操作会阻塞
- 写锁
    - 自身读操作正常，自身写操作正常
    - 其他读操作会阻塞，其他写操作会阻塞

行锁加锁规则：
- 读锁
    - 自身事务读操作正常，自身事务写操作正常
    - 其他事务读操作正常，其他事务写操作会阻塞
- 写锁
    - 自身事务读操作正常，自身事务写操作正常
    - 其他事务读操作正常（简单的读操作走 MVCC 快照读，加锁的读操作阻塞），其他事务写操作会阻塞

为什么上了写锁，别的事务还可以读操作？
因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

select * from information_schema.INNODB_LOCKS;

- 同一个事务加的 `GAP LOCK` 是可以插入的
- 多用唯一联合索引

S-共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。
X-排他锁: 又叫写锁，一旦加了写锁之后，其他事务就不能加锁了

---

在计算机系统中，多个进程或者多个线程并发访问一个共享资源时，都需要锁的保护，数据库也不例外。在数据库中，除了 CPU/MEM/IO 这些
由操作系统管控的共享资源外，数据也是一种会被并发事务访问的共享资源，数据库的锁就是用来保护这些数据一致性和有效性的工具

数据库的锁有粒度大小之分，粒度越大，锁冲突发生的概率就越大，并发性能越低。同时锁的各种操作（检测锁、获取锁、释放锁等）都会消耗系统资源

下面可能会对一些概念进行验证，运行的系统环境是：

- Ubuntu 18.04 LTS
- MySQL 5.7.33
- 测试数据是 [employees.sql](https://github.com/datacharmer/test_db)

> 以下的读操作指的是 `SELECT`，写操作指的是 `INSERT`|`UPDATE`|`DELETE`

## 锁的类型

MySQL 提供了表锁和行锁两种大的锁类型。表锁由 MySQL 服务器实现，无论你的存储引擎是什么都能使用表锁，而行锁是由特定的存储引擎实现，比如 InnoDB 默认是用行锁，
参考 [这个](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%A6%82%E8%BF%B0.md#%E6%9E%B6%E6%9E%84%E6%A6%82%E5%86%B5)

行锁和表锁的对被如下：

- 表锁：开销少，加锁快，不会出现死锁，锁的粒度大，发生锁冲突的概率高，并发程度低
- 行锁：开销大，加锁慢，会出现死锁，锁的粒度小，发生锁冲突的概率低，并发程度高

### 表锁

表锁是指对一整张表加锁，一般是 DDL 处理时使用，但是也可以在 DML 中手动指定。表锁又可以细分为读锁和写锁两种

#### (1)重要的特性

- MyISAM 只能使用表锁，在 MyISAM 下，读操作默认上读锁，写操作默认上写锁
- InnoDB 默认使用的是行锁，只有在没有索引或者索引失效的情况下，才会退化成使用表锁

#### (2)手动上锁

读锁：

```SQL
lock table <table_name1> read, <table_name2> read, ...;
<some_sql>
unlock tables;
```

写锁：

```SQL
lock table <table_name1> write, <table_name2> write, ...;
<some_sql>
unlock tables;
```

#### (3)读锁的规则

1. 持有读锁的会话可以读操作，但不能写操作，会报错，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-5.png)
2. 允许多个会话同时申请、持有读锁，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-6.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-7.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-8.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-9.png)
3. 没有持有读锁的会话也能读操作，但是不能写操作，会被阻塞，直到读锁被释放，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-10.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-11.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-12.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-13.png)
4. 如果读锁还没释放，其他会话试图申请写锁时，会被阻塞，直到读锁被释放，验证 ✅
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-14.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-15.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-16.png)
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-17.png)

**🌟 表锁的读锁规则：对于加了读锁的会话，会阻塞任何会话（包括持有读锁的会话本身，自身不会阻塞，会直接报错）
对于同一个表的写操作或者申请写锁的操作，直到锁被释放**

#### (4)写锁的规则

1. 持有写锁的会话既可以读操作，也可以写操作
2. 如果写锁还没释放，其他会话既不可以读操作，也不可以写操作，会被阻塞，直到写锁被释放
3. 如果写锁还没释放，其他会话既不可以申请读锁，也不可以申请写锁，会被阻塞，直到写锁被释放

**🌟 表锁的写锁规则：对于加了写锁的会话，会阻塞其他会话对于同一个表的任何操作（读写操作、申请锁的操作），直到锁被释放**

#### (5)锁的释放时机

1. 使用 `UNLOCK TABLES` 手动释放
2. 如果会话在持有锁的情况下再次执行 `LOCK TABLE`，之前持有的锁将会被释放
3. 如果会话在持有锁的情况下执行 `BEGIN` 开启事务，之前持有的锁将会被释放
4. 如果断开连接，之前锁持有的锁将会被释放

#### (6)一次性封锁

表锁使用的是一次性封锁原则，也就是说一个会话一旦加了锁，在释放锁、或者重新加锁之前，都只能操作加锁的表，验证 ✅

![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-18.png)

### 行锁

行锁是指加在索引列上的锁，索引结构可以参考 [这里](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84) 。 
行锁一般用于事务里的 DML 操作。行锁又可以细分为 `Record-Lock`（记录锁）、`Gap-Lock`（间隔锁）、`Next-Key-Lock`（记录锁加间隔锁）、`LOCK_INSERT_INTENSION`（插入意向锁，插入记录时使用，是间隔锁的一种特例）

#### (1)重要的特性

- InnoDB 默认（RR 隔离级别）使用的是行锁，具体来说是 `Next-Key-Lock`，只有在没有索引或者索引失效的情况下，才会退化成使用表锁；如果索引是主键索引或者唯一索引，
  `Next-Key Lock` 会升级成 `Record-Lock`
- InnoDB 下的读操作是快照读，默认不加锁（但是也可以手动上锁），对于写操作默认加写锁
- 如果非聚簇索引都会引发 [回表](https://github.com/hsxhr-10/Blog/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95) ，
  那么回表也将会影响到加锁的操作，具体来说就是二级索引的索引记录会被上锁，对应的聚簇索引记录也会被上锁，如下图所示：
  ![](https://raw.githubusercontent.com/hsxhr-10/Blog/master/image/mysql-19.png)
- MySQL 的加锁步骤是按照查询结果一条条加的，比如 `update students set level = 3 where score >= 60;` 查询出来 100 条，而且 score 是二级索引，
  那么理论上就要进行 200 次的加锁操作
- 行锁下面的四种锁模式都有读锁和写锁之分

#### (2)手动上锁

- 读锁：
  ```SQL
  SELECT ... LOCK IN SHARE MODE;
  ```
- 写锁：
  ```SQL
  SELECT ... FOR UPDATE;
  ```

#### (3)读锁的规则

**🌟 行锁的读锁规则：对于加了读锁的事务，会阻塞其他事务对于同一行数据的写操作或者申请写锁的操作，直到锁被释放**

#### (4)写锁的规则

**🌟 行锁的写锁规则：对于加了写锁的事务，会阻塞其他事务对于同一行数据的写操作或者申请读、写锁的操作，直到锁被释放**

> 表锁是会话和同一个表之间的作用关系，行锁是事务和同一行数据之间的作用关系

#### (5) 四种行锁的模式

##### (1)记录锁

##### (2)间隔锁

##### (3)Next-Key-Lock

##### (4)插入意向锁

> 读意向锁和写意向锁是用来加快检测表锁是否会与行锁冲突的工具
