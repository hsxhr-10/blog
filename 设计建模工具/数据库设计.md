# 数据库设计

1. 数据库设计的概念和作用
2. 三个范式
3. 约束
4. ER 图
5. 根据实际的数据库系统，DDL、约束、存储引擎/字符集
6. 最佳实践

这里的数据库特指关系型数据库。而数据库设计指的是根据需求，在某一个实际的数据库管理系统上（比如 MySQL），设计数据库、数据表结构的过程，不是设计数据库管理系统（DBMS） 🐶

基本上现在的应用系统都离不开数据库了，都属于数据库应用系统。如果是比较小的项目，那可能没必要进行数据库设计，因为太简单了，一眼看到头，直接建表开干就完事了。
但是如果是表比较多的、业务关系比较复杂的项目，数据库设计就有必要了，它可以帮忙理清业务逻辑、节省数据存储空间、让上层应用系统能够高效地对业务数据进行存储和访问。

## 数据库设计步骤

1. 需求分析。这个阶段一般通过流程图、原型图、设计图，或者和产品经理口头交流，了解需求是什么
2. 根据需求分析得到的信息，进行实例和关系的抽象，可以从某一个实例出发，逐步建立局部 ER 图。这阶段可能会遇到不少问题，需要反复回溯到需求分析阶段，需要一定的耐性。最终一般会整理出多个局部的 ER 图
3. 合并多个局部 ER 图成一个全局 ER 图。这个阶段可能需要解决局部图的冲突、冗余等问题
4. 建表。这个阶段需要选择合适的存储引擎、字符集、写 DDL 语句等
5. 倒入适量的测试数据，进行应用程序的开发。这个阶段可能需要调整、修改表结构
6. 根据应用程序的 SQL 语句特点，确定索引设计

> 关于索引的设计，如果在需求分析阶段已经基本确定应用程序的相关 SQL 怎么写，那也可以提前建索引，看实际情况吧

## 三个范式

范式，一个很厉害的名字，其实差不多可以理解成规则吧。三个范式可以帮助我们建立结构清晰的表结构、减少数据冗余、增强数据完整性。因为书上对三个范式的描述是比较严谨学术的，
不过这也导致本来不算太复杂的东西容易看得人云里雾里，下面口语化地描述下它们的定义，比较官方权威的描述也可以看 [这里](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96)

- 第一范式：每个列（属性）应该是不能再细分的概念（比如有一个叫做「区域」的属性值是 "广东省广州市天河区黄埔大道1号"，理论上这个属性还可以拆分成「省」、 「市」、「区」、「街道」等多个属性）
- 第二范式：每个表（实体）之间应该相互独立，同时有且只有一个主键
- 第三范式：每个实体都不应该包含（冗余）有其他实体的属性，如果有冗余，则用外键关联

范式虽好，但是就像设计模式那样，一味遵守不如没有 🐶 ，适当地发范式设计可能可以让结构更加灵活、查询效率更好。第一和第二范式基本上是要遵守的，反的主要是第三范式。
适当地增加冗余数据可以避免多表查询，一定程度上降低查询的复杂度和提高效率；减少外键的使用，改成用 id 进行关联则可以让表结构更加灵活、降低数据库资源的消耗

## 常用约束

约束是一种限制，可以保护数据的完整性和有效性。不同的 DBMS 提供的约束可能会有所不同，下面以 MySQL 为例记录

### 主键约束

- 用来唯一标记每一天记录
- 不能为 NULL
- 一般和业务逻辑无关
- 常见主键形式有：自增的整数做主键、UUID 做主键、多字段联合做主键
- 关于联合主键
    - 联合主键中每个字段只能出现一次，如果某个字段被删除了，剩下字段组成的联合主键仍然是唯一的，那么这个联合主键就是不正确的
    - 联合主键语法：`PRIMARY KEY (id, name)`
- 自增主键 AUTO_INCREMENT
    - 默认情况下从 1 开始，可以执行初始值，比如 `AUTO_INCREMENT=100`
    - 必须有非空约束
    - 对应的字段类型必须是（TINYINT、SMALLINT、INT、BIGINT 之一）
    - 当字段值大于类型的取值范围时，AUTO_INCREMENT 会失败
    - 自增主键的不连续：当并发插入时，前一条插入失败回滚后，会造成不连续。解决方法是将事务级别调到最高的 Serialiable，但是这样会降低性能，实际一般不会这样做，
        前面也提到过主键应该是与业务逻辑无关的，所以不连续不应该造成什么问题
    - 自增主键的不单调：指的是 id=10 的数据被删除过了，后续还可能会插入一条 id=10 的数据，如果这个 id=10 被其他表引用，那么就可能会发生数据错误。解决方法是
        禁止物理删除，改成逻辑删除，或者升级 MySQL 版本到 8.0
- 可以用 DDL 语句 `CREATE`、`ALTER` 创建、删除主键约束

### 非空约束

- 用来确保列的值不能为 NULL
- 可以用 DDL 语句 `CREATE`、`ALTER` 创建、删除非空约束

### 默认值约束

- 用来确保列有默认值
- 通常和非空约束搭配使用
- 可以用 DDL 语句 `CREATE`、`ALTER` 创建、删除默认值约束

### 唯一约束

- 用来确保列的取值唯一
- 可以为 NULL
- 与主键约束的区别：都可以限制唯一，但是一个表中多个列都可以加唯一约束，但只能有一个列是主键约束
- 加了唯一约束的列会被加上唯一索引
- 可以用 DDL 语句 `CREATE`、`ALTER` 创建、删除唯一约束

### 检查约束

- 用来做一些简单的值的有效性检查（比如 age 列不能小于 0）
- 一般数值类型的字段用检查约束比较多
- 可以用 DDL 语句 `CREATE`、`ALTER` 创建、删除检查约束

### 外键约束

- 用来确保数据的完整性。比如插入父表数据时，外键必须是对应的子表主键，不能是其他乱七八糟的东西；删除主表的数据时，子表的对应数据要先删除
- 父表的一个外键会对应一个子表的主键
- 外键可以为 NULL
- 可以用 DDL 语句 `CREATE`、`ALTER` 创建、删除外键约束

> 一个数据表中，主键约束只能有一个，其他约束可以有多个。查看约束的 SQL：`SHOW CREATE TABLE <表名> \G;`

## ER 图

ER 图的画法比 UML 更加灵活，基本上没有统一的画法，个人觉得只要能清晰表明意思即可

- 实体一般用矩形表示，包括自身的名字，包含的属性名字、数据类型、约束
- 关系一般用棱形表示，有些标准需要画出来，有些不需要特意把关系画出来，个人偏向后者



## 实施

## 最佳实践

## 参考

- [为什么 MySQL 的自增主键不单调也不连续](https://draveness.me/whys-the-design-mysql-auto-increment/)
